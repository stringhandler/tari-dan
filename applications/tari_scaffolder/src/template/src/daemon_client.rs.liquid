
use multiaddr::Multiaddr;
use std::str::FromStr;
use reqwest;
use serde_json::json;
use serde_json::Value;
use tari_engine_types::instruction::Instruction;
use tari_wallet_daemon_client::types::TransactionSubmitRequest;
use tari_wallet_daemon_client::WalletDaemonClient;
use tari_wallet_daemon_client::ComponentAddressOrName;
use tari_wallet_daemon_client::types::CallInstructionRequest;

pub struct DaemonClient {
    endpoint: String,
    auth_token: String,
    last_id: usize,
}

impl DaemonClient {
    pub(crate) fn new(endpoint: String, auth_token: String) -> Self {
        Self {
            endpoint,
            auth_token,
            last_id: 0,
        }
    }

    async fn call_wallet(&mut self, method: &str, params: Value) {
        self.last_id += 1;
        let client = reqwest::Client::new();
	let body =  json!({
                    "jsonrpc":"2.0",
                    "method": method,
                    "id": self.last_id,
                    "params": params
                })
                .to_string();
	dbg!(&body);
        let res = client
            .post(&self.endpoint)
            .header("Authorization", format!("Bearer {}", self.auth_token))
            .json(
               &body
            )
            .send()
            .await
            .unwrap();

        let res_json: Value = res.json().await.unwrap();

        dbg!(res_json);
    }


    pub async fn submit_instruction(&mut self, instruction: Instruction, dump_buckets: bool, is_dry_run: bool, fees: u64) {
     let mut client =
            WalletDaemonClient::connect(&self.endpoint, Some(self.auth_token.clone())).unwrap();
        //let r = client.list_keys().await;

        //dbg!(r);

           let tx = CallInstructionRequest {
            instruction,
            fee_account: ComponentAddressOrName::Name("TestAccount_0".to_string()),
            dump_outputs_into: if dump_buckets {
                Some(ComponentAddressOrName::Name("TestAccount_0".to_string()))
            } else {
                None
            },
            fee: fees,
            inputs: vec![],
            override_inputs: None,
            new_outputs: None,
            specific_non_fungible_outputs: vec![],
            new_resources: vec![],
            new_non_fungible_outputs: vec![],
            new_non_fungible_index_outputs: vec![],
            is_dry_run,
            proof_ids: vec![],
        };

        let r2 = client.submit_instruction(tx).await.unwrap();


        dbg!(r2);



	    //"dump_outputs_into": "TestAccount_0",

    }

              //  {
                //    "instruction": instruction,
                  //  "fee_account": self.last_account_name,
               //     "dump_outputs_into": self.last_account_name,
               //     "fee": 1000,
               // },
          //
}
